package com.example.android.camera2basic;


import android.app.Activity;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.util.Log;

import static android.content.Context.SENSOR_SERVICE;

public final class GameRotationVectorSensor
{
    private static GameRotationVectorSensor instance;
    private static final String TAG = "GRVSensor";
    private static Activity parentActivity = null;

    protected SensorManager       sensorManager   = null;
    protected Sensor              sensor = null;
    protected SensorEventListener sensorListener = null;

    private GameRotationVectorSensor()
    {
        // Constructor hidden because this is a singleton
        // use GameRotationVectorSensor.getInstance() instead of new GameRotationVectorSensor
    }

    public static GameRotationVectorSensor getInstance(Activity activity)
    {
        if (instance == null)
        {
            // Create the instance
            instance = new GameRotationVectorSensor();
        }
        // always update parent activity - different activities may be calling us
        instance.parentActivity = activity;
        // Return the instance
        return instance;
    }

    private SensorManager getSensorManager() {
        // always acquire latest system services from activity that is using this class.
        this.sensorManager = (SensorManager) this.parentActivity.getSystemService(SENSOR_SERVICE);
        return this.sensorManager;
    }

    public Sensor getSensor(SensorManager sensorManager) {
        if( this.sensor == null ) {
            this.sensor = sensorManager.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR);
        }
        return this.sensor;
    }

    public void registerSensor() {
        SensorManager sensorManager = getSensorManager();
        final Sensor localSensor = getSensor(sensorManager);

        String message = "Game Rotation Vector sensor is available.\n";
        if(localSensor == null) {
            message = "Game Rotation Vector sensor not available.\n";
            return;
        }
        Log.e(TAG, message);

        // Create listener
        this.sensorListener = new SensorEventListener() {

            @Override
            public void onAccuracyChanged(Sensor sensor, int i) {
            }

            @Override
            public void onSensorChanged(SensorEvent sensorEvent) {
                handleSensorEvent(sensorEvent);
            }
        };

        // Register it, specifying the normal delay
        sensorManager.registerListener(this.sensorListener,
                localSensor, SensorManager.SENSOR_DELAY_NORMAL);
    }


    public void unregisterSensor() {
        SensorManager sensorManager = getSensorManager();
        sensorManager.unregisterListener(this.sensorListener);
    }

    protected void handleSensorEvent(SensorEvent sensorEvent) {

        float[] orientations = getOrientationsArray(sensorEvent);

        Log.e(TAG, "X-Axis rotation: " + orientations[0] + "\n");
        Log.e(TAG, "Y-Axis rotation: " + orientations[1] + "\n");
        Log.e(TAG, "Z-Axis rotation: " + orientations[2] + "\n");
    }

    /**
     * get the orientations array (rotations against [X,Y,Z]) in degrees as an array of floats.
     *
     * The rotation vector sensor combines raw data generated by the gyroscope, accelerometer,
     * and magnetometer to create a quaternion. Consequently, the values array of its SensorEvent
     * object has the following five elements:
     *
     *  - The X, Y, Z, and W components of the quaternion
     *  - A heading accuracy
     *
     * You can convert the quaternion into a rotation matrix, a 4x4 matrix, by using the
     * getRotationMatrixFromVector() method of the SensorManager class.
     *
     * If you are developing an OpenGL app, you can use the rotation matrix directly to transform
     * objects in your 3D scene. For now, however, let us convert the rotation matrix into an
     * array of orientations, specifying the rotation of the device along the Z, X, and Y axes.
     * To do so, we can use the getOrientation() method of the SensorManager class.
     *
     * Before you call the getOrientation() method, you must remap the coordinate system of the
     * rotation matrix. More precisely, you must rotate the rotation matrix such that the Z-axis
     * of the new coordinate system coincides with the Y-axis of the original coordinate system.
     *
     * @param sensorEvent the given SensorEvent
     * @return [X,Y,Z] orientations array in degrees as an array of floats.
     */
    private float[] getOrientationsArray(SensorEvent sensorEvent) {
        float[] rotationMatrix = new float[16];
        SensorManager.getRotationMatrixFromVector( rotationMatrix, sensorEvent.values);

        // Remap coordinate system
        float[] remappedRotationMatrix = new float[16];
        SensorManager.remapCoordinateSystem(rotationMatrix,
                SensorManager.AXIS_X,
                SensorManager.AXIS_Z,
                remappedRotationMatrix);

        // Convert to orientations
        float[] orientations = new float[3];
        SensorManager.getOrientation(remappedRotationMatrix, orientations);


        // Convert from Radians to Degrees
        for(int i = 0; i < 3; i++) {
            orientations[i] = (float)(Math.toDegrees(orientations[i]));
        }
        return orientations;
    }

}